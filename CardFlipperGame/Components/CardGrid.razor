@using System.IO
@using CardFlipperGame.Saving
@using BlazorDownloadFile
@using Newtonsoft.Json
@inject IJSRuntime JSRuntime

<h3>@this.StateText</h3>
@if (this.GameOn && this.MatchesLeft > 0)
{
    <h4>Mismatches: @this.Mismatches.ToString()</h4>
}

<div style="@this.DynamicCss">
    <div class="game-container container">
        @if (this.GameOn)
        {
            @for (int r = 0; r < this.RowCount; r++)
            {
                <div class="row">
                    @for (int c = 0; c < this.ColumnCount; c++)
                    {
                        int index = (r * this.RowCount) + c;
                        <div class="@this.SimpleGridColClass">
                            <CardDisplay DisplayedSide="@this.TrackedCards[index]" Grid="@this" Index="@index" IsHiding="@(!IsMatched(index))" />
                        </div>
                    }
                </div>
            }
        }
        else
        {
            <div class="row">
                @for (int i = MinCardPairs; i <= MaxCardPairs; i++)
                {
                    var pairs = i * i;
                    <div class="col-3">
                        <div class="gamecard-box">
                            <div class="gamecard-hidingside gamecard-inner">
                                <span class="btn gamecard-text" @onclick="e => GeneratedItemsToDisplay(pairs)">@i.ToString()</span>
                            </div>
                        </div>
                    </div>
                }
            </div>
        }
    </div>
</div>

@if (this.GameOn)
{
    <div class="game-score">
        <div><h3>Matched @this.PairsToMatch Pairs with @this.Mismatches mismatched</h3></div>
        <button @onclick="StartNewGame" class="btn newgamebtn"><h2>Start a new game?</h2></button>
        @if (this.GameOn && this.MatchesLeft > 0)
        {
            <button class="btn newgamebtn" @onclick="SaveGameDownload"><h2>Save game</h2></button>
        }
    </div>
}
else
{
    <div>
        <h3>Continue previous game</h3>
        <input placeholder="JSON Text Here" @bind="priorGame" />
        <button @onclick="ReadText">Create</button>
    </div>
}

@code
{
    public const int MinCardPairs = 2;
    public const int MaxCardPairs = 9;
    public const int SecondsToWaitOnMismatch = 3;

    private CardDisplay lastCard = null;
    private string priorGame = null;

    public int RowCount { get; set; } = -1;

    public int ColumnCount { get; set; } = -1;

    public int PairsToMatch { get; set; } = 0;

    public IList<string> TrackedCards { get; set; }

    public string SimpleGridColClass => $"col-{12 / this.ColumnCount}";

    public bool IsWaiting { get; private set; } = false;

    public string DynamicCss { get; set; } = string.Empty;

    public string StateText { get; set; } = "Select pairs to match";

    public bool GameOn { get; set; } = false;

    public int Mismatches { get; set; } = 0;

    public int MatchesLeft { get; set; } = -1;

    public int Seed { get; set; } = 100000;

    public List<int> FoundMatches { get; } = new List<int>();

    [Inject]
    IBlazorDownloadFileService BlazorDownloadFileService { get; set; }

    public bool IsMatched(int index)
    {
        return this.FoundMatches.Contains(index);
    }

    public async Task CheckForMatch(CardDisplay card)
    {
        if (lastCard == null)
        {
            // First pick
            lastCard = card;
            this.StateText = "Find the next match";
            this.FoundMatches.Add(card.Index);
        }
        else if (lastCard != card && lastCard.DisplayedSide == card.DisplayedSide)
        {
            // Match found
            lastCard = null;
            this.MatchesLeft--;
            this.FoundMatches.Add(card.Index);

            if (this.MatchesLeft > 0)
            {
                this.StateText = "You found a match!";
            }
            else
            {
                this.StateText = "You win!";
                this.DynamicCss = "background-color: royalblue;";
            }
        }
        else
        {
            // No match
            this.StateText = "Sorry - No match";
            this.Mismatches++;
            this.IsWaiting = true;
            this.DynamicCss = "background-color: orangered;";
            base.StateHasChanged();

            // Intentionally not waiting
            await Task.Delay(SecondsToWaitOnMismatch * 1000);
            lastCard.FlipFaceDown();
            card.FlipFaceDown();
            this.FoundMatches.Remove(card.Index);
            this.FoundMatches.Remove(lastCard.Index);
            lastCard = null;
            this.StateText = "Match pairs!";
            this.DynamicCss = string.Empty;
        }

        this.IsWaiting = false;
        base.StateHasChanged();
    }

    private void GeneratedItemsToDisplay(int pairs)
    {
        var list = new List<string>(pairs);

        char letter = 'A';
        for (int i = 0; i < pairs; i++)
        {
            string display = letter.ToString();

            // Add a pair
            list.Add(display);
            list.Add(display);
            letter++;
        }

        Scramble(list);

        int square = (int)Math.Sqrt(list.Count);

        this.RowCount = square;
        this.ColumnCount = square;
        this.TrackedCards = list;
        this.PairsToMatch = pairs;

        this.MatchesLeft = pairs / 2;
        this.GameOn = true;
    }

    private void Scramble(List<string> list)
    {
        var rng = new Random(this.Seed);

        int lastIndex = list.Count - 1;
        for (int i = 0; i < list.Count; i++)
        {
            int randoIndex = rng.Next(0, lastIndex);
            string temp = list[i];
            list[i] = list[randoIndex];
            list[randoIndex] = temp;
        }
    }

    private void StartNewGame()
    {
        this.Seed++;
        this.Mismatches = 0;
        this.FoundMatches.Clear();
        this.MatchesLeft = -1;
        this.DynamicCss = string.Empty;
        this.StateText = "Select pairs to match";
        this.GameOn = false;
    }

    private async Task SaveGameDownload()
    {
        var state = new GameState
        {
            Seed = this.Seed,
            Pairs = this.PairsToMatch,
            Mismatches = this.Mismatches,
            MatchesFound = this.FoundMatches.ToArray()
        };

        string fileContent = JsonConvert.SerializeObject(state);

        await BlazorDownloadFileService.DownloadFileFromText("cardflipper.txt", fileContent, "json");
    }

    private void ReadText()
    {
        if (!string.IsNullOrEmpty(priorGame))
        {
            GameState state = JsonConvert.DeserializeObject<GameState>(priorGame);
            this.Seed = state.Seed;
            GeneratedItemsToDisplay(state.Pairs);
            this.FoundMatches.AddRange(state.MatchesFound);
            this.Mismatches = state.Mismatches;
        }
    }
}
